{"version":3,"sources":["component/card/card.component.jsx","component/card-list/card-list.component.jsx","component/search-box/search-box.component.jsx","App.js","serviceWorker.js","index.js"],"names":["Card","props","className","alt","src","monster","id","name","email","CardList","monsters","map","key","SearchBox","placeholder","handleChange","type","onChange","App","e","setState","searchField","target","value","state","fetch","then","response","json","users","this","filteredMonsters","filter","toLowerCase","includes","Component","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"qVAIaA,G,MAAO,SAAAC,GAAK,OACvB,yBAAKC,UAAU,kBACb,yBACEC,IAAI,UACJC,IAAG,+BAA0BH,EAAMI,QAAQC,GAAxC,4BAEL,4BAAKL,EAAMI,QAAQE,MACnB,2BAAIN,EAAMI,QAAQG,UCJTC,G,MAAW,SAAAR,GACtB,OACE,yBAAKC,UAAU,aAEZD,EAAMS,SAASC,KAAI,SAAAN,GAAO,OAGzB,kBAAC,EAAD,CAAMO,IAAKP,EAAQC,GAAID,QAASA,UCT3BQ,G,MAAY,SAAC,GAAD,EAAGC,YAAH,IAAgBC,EAAhB,EAAgBA,aAAhB,OAEvB,2BACEb,UAAU,SACVc,KAAK,SACLF,YAAY,kBAEZG,SAAUF,MCkDCG,G,kBArDb,aAAe,IAAD,8BACZ,+CAkBFH,aAAe,SAAAI,GACb,EAAKC,SAAS,CAAEC,YAAaF,EAAEG,OAAOC,SAjBtC,EAAKC,MAAQ,CACXd,SAAU,GACVW,YAAa,IALH,E,iFAUO,IAAD,OAElBI,MAAM,8CACHC,MAAK,SAAAC,GAAQ,OAAIA,EAASC,UAC1BF,MAAK,SAAAG,GAAK,OAAI,EAAKT,SAAS,CAAEV,SAAUmB,S,+BASnC,IAAD,EAIHC,KAAKN,MAFPd,EAFK,EAELA,SACAW,EAHK,EAGLA,YAIIU,EAAmBrB,EAASsB,QAAO,SAAA3B,GAAO,OAC9CA,EAAQE,KAAK0B,cAAcC,SAASb,EAAYY,kBAGlD,OACE,yBAAK/B,UAAU,OACb,gDAGA,kBAAC,EAAD,CACEY,YAAY,kBACZC,aAAce,KAAKf,eAIrB,kBAAC,EAAD,CAAUL,SAAUqB,S,GA9CVI,cCIEC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SD2H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMrB,MAAK,SAAAsB,GACjCA,EAAaC,kB","file":"static/js/main.83c36331.chunk.js","sourcesContent":["import React from \"react\";\r\n\r\nimport \"./card.styles.css\";\r\n\r\nexport const Card = props => (\r\n  <div className=\"card-container\">\r\n    <img\r\n      alt=\"monster\"\r\n      src={`https://robohash.org/${props.monster.id}?set=set2&size=180x180`}\r\n    />\r\n    <h2>{props.monster.name}</h2>\r\n    <p>{props.monster.email}</p>\r\n  </div>\r\n);\r\n","import React from \"react\";\r\n\r\nimport { Card } from \"../card/card.component\";\r\n\r\nimport \"./card-list.styles.css\"; //import css\r\n// className\"card-list\" comes form the css\r\n\r\nexport const CardList = props => {\r\n  return (\r\n    <div className=\"card-list\">\r\n      {/* map() = iterate over an array, has a callback function thats call in every element and then returns a new array*/}\r\n      {props.monsters.map(monster => (\r\n        //monster.id its necessary because react needs to now in case of change one element witch element we are referring\r\n        //<h1 key={monster.id}>{monster.name}</h1>\r\n        <Card key={monster.id} monster={monster} /> //where we pass monster to the Card component\r\n      ))}\r\n    </div>\r\n  );\r\n};\r\n","import React from \"react\";\r\n\r\nimport \"./search-box.styles.css\";\r\n\r\n//destructuring props\r\nexport const SearchBox = ({ placeholder, handleChange }) => (\r\n  // Search */\r\n  <input\r\n    className=\"search\"\r\n    type=\"search\"\r\n    placeholder=\"search monsters\"\r\n    //onChange={e => this.setState({ searchField: e.target.value })}//(code when it was in app.js) onchange comes with react JSX and fires when input is change and gives us a big object e, but the most used ones are target, get and set, then this will gives back the html element, then we want the value of that html element, the string we type in the search box*/}\r\n    onChange={handleChange}\r\n  />\r\n);\r\n","import React, { Component } from \"react\";\n// import logo from \"./logo.svg\";\n\nimport { CardList } from \"./component/card-list/card-list.component\"; //import component made by me\nimport { SearchBox } from \"./component/search-box/search-box.component\";\n\nimport \"./App.css\";\n\nclass App extends Component {\n  constructor() {\n    super();\n\n    this.state = {\n      monsters: [],\n      searchField: \"\"\n    };\n  }\n\n  //Component Life cycle are methods that get call at different stages(auto by react), when this component gets render\n  componentDidMount() {\n    //fetch makes a api call and returns a promise, note we can catch error if we want ex: .catch(err => console.log(\"Error!\"));\n    fetch(\"https://jsonplaceholder.typicode.com/users\")\n      .then(response => response.json()) //taking the response and converting to json format, because its a promise that response will be raped in a new resolve promise so that way we can call .then\n      .then(users => this.setState({ monsters: users })); //set our monsters to that response array of users\n  }\n\n  //my method, we need to use arrow func, so 'this' reference to the component\n\n  handleChange = e => {\n    this.setState({ searchField: e.target.value });\n  };\n\n  render() {\n    const {\n      monsters,\n      searchField\n    } = this.state; /*where we are destructuring an object, in this case the this.state object, this way we are pulling monster and searchField from the object and set then to const */\n\n    //using arrays methods filter and includes\n    const filteredMonsters = monsters.filter(monster =>\n      monster.name.toLowerCase().includes(searchField.toLowerCase())\n    );\n\n    return (\n      <div className=\"App\">\n        <h1>Monsters Rolodex</h1>\n\n        {/* Search- moved to its own component */}\n        <SearchBox\n          placeholder=\"search monsters\"\n          handleChange={this.handleChange}\n        />\n\n        {/* use component made by me and pass truth props and props.children */}\n        <CardList monsters={filteredMonsters}>\n          {/* this will take everything in this CardList and passes in the component cardlist(props.children) given in this case a grid/style, note :now we move the code and pass state above */}\n        </CardList>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}